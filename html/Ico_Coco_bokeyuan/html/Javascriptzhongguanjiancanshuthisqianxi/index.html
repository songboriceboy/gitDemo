<!DOCTYPE html>

<html lang="zh">
    <head>
        <meta charset="utf-8">
        <meta name="description" content="QQ空间，新浪博客，宝宝树博客，豆瓣日记，天涯博客，简书，博客园，和讯博客，CSDN博客，Iteye博客，搜狐博客，51CTO,Iteye,Itpub,ChinaUnix" />
        <meta name="keywords" content="QQ空间，新浪博客，宝宝树博客，豆瓣日记，天涯博客，简书，博客园，和讯博客，CSDN博客，Iteye博客，搜狐博客，51CTO,Iteye,Itpub,ChinaUnix" />

        <title>博客备份专家博客备份演示站</title>
        <style type='text/css'>
            body {
                background-color: #CCC;
            }
        </style>
        <link rel="stylesheet" href="../../../../css/bootstrap.css" />
        <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"tiantiancode"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->
    </head>

    <body>
        <div class="container">

            <h1>博客备份专家博客备份演示站</h1>

            <div class='navbar navbar-inverse'>
                <div class='navbar-inner nav-collapse' style="height: auto;">
                    <ul class="nav">
                              				<li><a href="http://songboriceboy.github.io/gitDemo/html/guweiling_xinlang/index.html">谷为陵_新浪</a></li>
    				          				<li><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/index.html">Jack_King007的专栏_CSDN</a></li>
    				          				<li><a href="http://songboriceboy.github.io/gitDemo/html/Ico_Coco_bokeyuan/index.html">Ico_Coco_博客园</a></li>
    				                      </ul>
                </div>
            </div>

            <div id='content' class='row-fluid'>

                <div class='span9 main'>
                <ul class="breadcrumb">
                    <li><a href="http://songboriceboy.github.io/gitDemo/html/Ico_Coco_bokeyuan/index.html">Ico_Coco_博客园</a> <span class="divider">/</span></li>
                    <li><a href="http://songboriceboy.github.io/gitDemo/html/Ico_Coco_bokeyuan/html/index.html">html</a> <span class="divider">/</span></li>
                    <li class="active">Javascript中关键参数this浅析</li>
                </ul>
           <ul class="pager">
  <li class="previous"><a href="http://songboriceboy.github.io/gitDemo/html/Ico_Coco_bokeyuan/html/javascriptzhonghanshushengminghehanshubiaodashiqianxi/index.html">&larr; javascript中函数声明和函数表达式浅析</a></li>
  <li class="next"><a href="http://songboriceboy.github.io/gitDemo/html/Ico_Coco_bokeyuan/html/javascriptzhonghanshushengminghehanshubiaodashiqianxi/index.html">innerHTML与innerText的异同 &rarr;</a></li>
</ul>
				<div style="color:blue" align=center>Javascript中关键参数this浅析</div><br><p><span style="font-size: 14px; font-family: 'Microsoft YaHei';">　　自从接触javascript以来，对this参数的理解一直是模棱两可。虽有过深入去理解，但却也总感觉是那种浮于表面，没有完全理清头绪。</span></p>
<p><span style="font-size: 14px; font-family: 'Microsoft YaHei';">　　但对于this参数，确实会让人产生很多误解。那么this参数到底是何方神圣？</span></p>
<p><span style="font-size: 14px; font-family: 'Microsoft YaHei';">　　</span></p>
<p><span style="font-size: 14px; font-family: 'Microsoft YaHei';">　　<strong><span style="font-size: 14pt;">理解this</span></strong>　　</span></p>
<p><span style="font-size: 14px; font-family: 'Microsoft YaHei';">　　</span><span style="font-size: 14px; font-family: 'Microsoft YaHei';">this是一个与执行上下文（execution context，也就是作用域）相关的特殊对象。因此,它可以叫作上下文对象(也就是用来指明执行上下文是在哪个上下 文中被触发的对象)。&nbsp;</span></p>
<p><span style="font-family: 'Microsoft YaHei';"><span style="font-size: 14px;">　　</span><strong>任何对象都可以做为上下文中的this的值。</strong>在一些对ECMAScript执行上下文和部分this的描述中的 所产生误解。this经常被错误的描述成是变量对象的一个属性。 再重复一次：</span></p>
<div class="page" title="Page 14">
<div class="section">
<div class="layoutArea">
<div class="column">
<p><span style="font-family: 'Microsoft YaHei';">　　this是执行上下文的一个属性,而不是变量对象的一个属性。 这个特性非常重要,因为与变量相反,this从不会参与到标识符解析过程。换句话说,在代码中当访问this的时候,它的值是直接从执行上下文中获取的,并不需要任何作用域链查找。this的值只在进入上下文的时候进行一次确定。&nbsp;</span></p>
</div>
</div>
</div>
</div>
<p><span style="font-size: 14px; font-family: 'Microsoft YaHei';">　　废话不多，先看一个板栗：</span>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> <span style="color: #000000;">var test = function(){};
</span><span style="color: #008080;"> 2</span> 
<span style="color: #008080;"> 3</span> <span style="color: #000000;">test.prototype = {
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">    foo:"apple",
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">    fun:function(){
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">        this.foo="banana";
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">};
</span><span style="color: #008080;"> 9</span> 
<span style="color: #008080;">10</span> <span style="color: #000000;">var myTest = new test();
</span><span style="color: #008080;">11</span> <span style="color: #000000;">myTest.fun();
</span><span style="color: #008080;">12</span> 
<span style="color: #008080;">13</span> <span style="color: #000000;">console.log(myTest.hasOwnProperty("foo"));  //输出什么    
</span><span style="color: #008080;">14</span> console.log(myTest.hasOwnProperty("fun"));  //输出什么</pre>
</div>
<blockquote>
<div id="text"><span style="color: #808080; font-family: 'Microsoft YaHei';">hasOwnProperty：是用来判断一个对象是否有你给出名称的属性或对象。不过需要注意的是，此方法无法检查该对象的原型链中是否具有该属性，该属性必须是对象本身的一个成员。</span></div>
</blockquote>
<p><span style="font-family: 'Microsoft YaHei';">　　不知道看官们心里的答案是什么，正确的答案是true,false。</span></p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #000000;">console.log(myTest.hasOwnProperty("foo"));
</span><span style="color: #008080;">2</span> <span style="color: #000000;">console.log(myTest.hasOwnProperty("fun"));
</span><span style="color: #008080;">3</span> 
<span style="color: #008080;">4</span> <span style="color: #000000;">true 
</span><span style="color: #008080;">5</span> false </pre>
</div>
<p>&nbsp;</p>
<p>　　<span style="font-family: 'Microsoft YaHei';">要弄明白为什么是这样，就必须要理解上面this所扮演的角色，所指代的对象。在《javascript语言精粹》一书中，指出了在javascript中一共有<strong>四种</strong>调用模式：</span></p>
<ol>
<li><span style="font-family: 'Microsoft YaHei';">　　方法调用模式</span></li>
<li><span style="font-family: 'Microsoft YaHei';">　　函数调用模式</span></li>
<li><span style="font-family: 'Microsoft YaHei';">　　构造器调用模式</span></li>
<li><span style="font-family: 'Microsoft YaHei';">　　apply调用模式</span></li>
</ol>
<p><span style="font-family: 'Microsoft YaHei';">　　而在这些模式当中，对于如何初始化关键参数this上是存在不同差异的。</span></p>
<p><span style="font-family: 'Microsoft YaHei';">　　</span></p>
<p><span style="font-family: 'Microsoft YaHei';"><strong><span style="font-size: 14pt;">&nbsp; &nbsp; 方法调用模式</span></strong></span></p>
<p><span style="font-family: 'Microsoft YaHei';"><span style="font-size: 14px;">　　当一个函数被保存为对象的一个属性时，我们称它为一个方法。<strong>当一个方法被调用时，this被绑定到该对象</strong>。注意加粗的这句是重点：</span></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> <span style="color: #000000;">// 创建myObject。它有一个value属性和一个increment方法
</span><span style="color: #008080;"> 2</span> 
<span style="color: #008080;"> 3</span> <span style="color: #000000;">var myObject = {
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">    value: 0;
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">    increment: function(inc) {
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">        this.value += typeof inc ==='number'?inc:1; // 接受一个可选参数，如果不是数字，则默认为数字1
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">};
</span><span style="color: #008080;"> 9</span> 
<span style="color: #008080;">10</span> <span style="color: #000000;">myObject.increment();
</span><span style="color: #008080;">11</span> <span style="color: #000000;">console.log(myObject.value);    // 1
</span><span style="color: #008080;">12</span> 
<span style="color: #008080;">13</span> <span style="color: #000000;">myObject.increment(2);          //传入数字2
</span><span style="color: #008080;">14</span> console.log(myObject.value);    // 3</pre>
</div>
<p>　　<span style="font-family: 'Microsoft YaHei';">这里，方法increment可以使用this去访问myObject对象，所以可以改变value的值。而且，<strong>this到对象的绑定发生在调用的时候</strong>。</span></p>
<p>　　</p>
<p>　　<span style="font-family: 'Microsoft YaHei';"><strong><span style="font-size: 14pt;">函数调用模式</span></strong></span></p>
<p><span style="font-size: 19px; line-height: 28px;"><strong>&nbsp; &nbsp;&nbsp;</strong></span><span style="font-size: 14px; font-family: 'Microsoft YaHei';">如果一个函数并非一个对象的属性时，那么它被当作一个函数来调用，<strong>此时，this被绑定到全局对象</strong>，书上说这是js语言设计的一个缺陷。倘若设计正确，当内部函数被调用的时，this应该仍然绑定到外部函数的this变量。抛开对语言设计的正确与否讨论，要当函数调用模式时this变量依旧绑定到该对象，有如下经典解决方案:</span></p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> <span style="color: #000000;">// 给myObject增加一个double方法
</span><span style="color: #008080;"> 2</span> 
<span style="color: #008080;"> 3</span> <span style="color: #000000;">var myObject = {
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">    value: 0;
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">    increment: function(inc) {
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">        this.value += typeof inc ==='number'?inc:1; // 接受一个可选参数，如果不是数字，则默认为数字1
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">};
</span><span style="color: #008080;"> 9</span> 
<span style="color: #008080;">10</span> <span style="color: #000000;">myObject.increment(2);
</span><span style="color: #008080;">11</span> 
<span style="color: #008080;">12</span> <span style="color: #000000;">myObject.double = function () {
</span><span style="color: #008080;">13</span> <span style="color: #000000;">    var that=this;  //解决方法
</span><span style="color: #008080;">14</span>     
<span style="color: #008080;">15</span> <span style="color: #000000;">    var helper= function () {
</span><span style="color: #008080;">16</span> <span style="color: #000000;">        that.value=add(that.value,that.value);
</span><span style="color: #008080;">17</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">18</span> <span style="color: #000000;">    helper();
</span><span style="color: #008080;">19</span> <span style="color: #000000;">};
</span><span style="color: #008080;">20</span> <span style="color: #000000;">myObject.double();  //以方法的形式调用double
</span><span style="color: #008080;">21</span> console.log(myObject.getValue());   //6</pre>
</div>
<p>&nbsp;</p>
<p>　　<span style="font-family: 'Microsoft YaHei'; font-size: 14px;">即是给该方法定义一个变量并且把它赋值为this，那么内部函数就可以通过那个变量访问到this，按照约定，给那个变量命名为that。</span></p>
<p>&nbsp;</p>
<p>　　<span style="font-size: 14pt; font-family: 'Microsoft YaHei';"><strong>构造器调用模式</strong></span></p>
<p>　　<span style="font-family: 'Microsoft YaHei';">构造器调用模式即是我一开头给出的例子所提到的。如果在一个函数前面带上new来调用，那么将创建一个连接到该函数的prototype成员新对象，<strong>同时this将会被绑定到那个新对象上</strong>。听上去十分拗口且难以理解，先再看个demo：</span></p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> <span style="color: #000000;">//构造一个名为Quo的构造器函数，带有一个status属性的对象
</span><span style="color: #008080;"> 2</span> 
<span style="color: #008080;"> 3</span> <span style="color: #000000;">var Quo = function(string){
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">    this.status =string;
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">};
</span><span style="color: #008080;"> 6</span> 
<span style="color: #008080;"> 7</span> <span style="color: #000000;">Quo.prototype.get_status = function(){
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">    return this.status;
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">}
</span><span style="color: #008080;">10</span> 
<span style="color: #008080;">11</span> <span style="color: #000000;">var myQuo =new Quo("confuse");  //构造一个Quo实例
</span><span style="color: #008080;">12</span> 
<span style="color: #008080;">13</span> console.log(myQuo.get_status());  //confuse</pre>
</div>
<p>&nbsp;</p>
<p>　　<span style="font-size: 14px; font-family: 'Microsoft YaHei';">简单来说，Quo对象下的this在被用为构造一个新实例即new时，this指代的是新生成的myQuo对象而不是Quo对象本身。</span></p>
<p><span style="font-family: 'Microsoft YaHei';">　　<span style="font-size: 14px;">一句话，重点就是：</span><strong><span style="font-size: 16px;">原型中的this不是指的原型对象，而是调用对象。</span></strong></span></p>
<p><span style="font-family: 'Microsoft YaHei';"><span style="line-height: 1.5;">　　再回过头看一开始的demo，就很好理解了，在执行</span>myTest.fun()时，this指代了myTest对象，所以生成了一个foo属性值为&ldquo;banana&rdquo;，所以myTest.hasOwnProperty("foo")返回值为true。</span></p>
<p>　　</p>
<p>　　<span style="font-size: 14pt; font-family: 'Microsoft YaHei';"><strong>Apply调用模式</strong></span></p>
<p>　　<span style="font-size: 14px; font-family: 'Microsoft YaHei';">因为javascript是一门函数式面向对象编程语言，所以函数可以拥有方法。apply方法让我们构建一个参数数组并用其去调用其他函数，apply方法接收两个参数，第一个是将被绑定的this的值，第二个是参数数组。说简单直接一点就是apply方法能劫持另外一个对象的方法，继承另外一个对象的属性. 推荐可以看<span style="color: #3366ff;"><span style="color: #3366ff;"><a href="http://www.jb51.net/article/42705.htm" target="_blank">js中apply方法的使用详细解析&nbsp;</a><span style="color: #000000;">，就不摆demo了。</span></span></span></span></p>
<p><span style="color: #3366ff; font-size: 14px; font-family: 'Microsoft YaHei';"><span style="color: #3366ff;">　　</span></span></p>
<p><span style="color: #3366ff; font-size: 14px; font-family: 'Microsoft YaHei';"><span style="color: #3366ff;">　　<span style="color: #000000;">学识尚浅，若文中有不正确，请务必指出，误人子弟实乃大过。</span></span></span></p>
<p><span style="color: #3366ff; font-size: 14px; font-family: 'Microsoft YaHei';"><span style="color: #3366ff;"><span style="color: #000000;">　　转载注明出处：<a href="http://www.cnblogs.com/coco1s/p/3948151.html" target="_blank">http://www.cnblogs.com/coco1s/p/3948151.html</a></span></span></span></p>
<p><strong><span style="font-size: 14pt;">　　</span></strong></p>
<p>&nbsp;</p>
<p>　　</p>
<p>&nbsp;</p>
                <ul class="pager">
  <li class="previous"><a href="http://songboriceboy.github.io/gitDemo/html/Ico_Coco_bokeyuan/html/javascriptzhonghanshushengminghehanshubiaodashiqianxi/index.html">&larr; javascript中函数声明和函数表达式浅析</a></li>
  <li class="next"><a href="http://songboriceboy.github.io/gitDemo/html/Ico_Coco_bokeyuan/html/javascriptzhonghanshushengminghehanshubiaodashiqianxi/index.html">innerHTML与innerText的异同 &rarr;</a></li>
</ul>
<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="29609118296925" data-title="Javascript中关键参数this浅析" data-url="http://songboriceboy.github.io/gitDemo/html/Ico_Coco_bokeyuan/html/Javascriptzhongguanjiancanshuthisqianxi/index.html"></div>
<!-- 多说评论框 end -->
                </div>

                <div class='span3 sidebar'>
                    <h3>导航栏</h3>
                    <ul class="nav nav-tabs nav-stacked">
                             				<li><a href="http://songboriceboy.github.io/gitDemo/html/Ico_Coco_bokeyuan/Javascriptyouhua/index.html">Javascript优化[2]</a></li>
    				          				<li><a href="http://songboriceboy.github.io/gitDemo/html/Ico_Coco_bokeyuan/wangyezhanshi/index.html">网页展示[1]</a></li>
    				          				<li><a href="http://songboriceboy.github.io/gitDemo/html/Ico_Coco_bokeyuan/qianduankuangjialeiku/index.html">前端框架类库[1]</a></li>
    				          				<li><a href="http://songboriceboy.github.io/gitDemo/html/Ico_Coco_bokeyuan/html/index.html">html[19]</a></li>
    				          				<li><a href="http://songboriceboy.github.io/gitDemo/html/Ico_Coco_bokeyuan/Encourage/index.html">Encourage[2]</a></li>
    				                                         
                    </ul>

                    <section>
        <h3>最近评论</h3>
        <ul class="ds-recent-comments" data-num-items="10" data-show-avatars="0" data-show-time="0" data-show-title="0" data-show-admin="0" data-excerpt-length="18"></ul>
      </section>

                </div>
            </div>

        </div>
    </body>
</html>