<!DOCTYPE html>

<html lang="zh">
    <head>
        <meta charset="utf-8">
        <meta name="description" content="QQ空间，新浪博客，宝宝树博客，豆瓣日记，天涯博客，简书，博客园，和讯博客，CSDN博客，Iteye博客，搜狐博客，51CTO,Iteye,Itpub,ChinaUnix" />
        <meta name="keywords" content="QQ空间，新浪博客，宝宝树博客，豆瓣日记，天涯博客，简书，博客园，和讯博客，CSDN博客，Iteye博客，搜狐博客，51CTO,Iteye,Itpub,ChinaUnix" />

        <title>博客备份专家博客备份演示站</title>
        <style type='text/css'>
            body {
                background-color: #CCC;
            }
        </style>
        <link rel="stylesheet" href="../../../css/bootstrap.css" />
    </head>

    <body>
        <div class="container">

            <h1>博客备份专家博客备份演示站</h1>

            <div class='navbar navbar-inverse'>
                <div class='navbar-inner nav-collapse' style="height: auto;">
                    <ul class="nav">
                              				<li><a href="http://songboriceboy.github.io/gitDemo/html/guweiling_xinlang/index.html">谷为陵_新浪</a></li>
    				          				<li><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/index.html">Jack_King007的专栏_CSDN</a></li>
    				          				<li><a href="http://songboriceboy.github.io/gitDemo/html/Ico_Coco_bokeyuan/index.html">Ico_Coco_博客园</a></li>
    				                      </ul>
                </div>
            </div>

            <div id='content' class='row-fluid'>

                <div class='span9 main'>
                <ul>
                                         <li>
        <h3><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/javajichujiaqiang/guanchazheshejimoshi/index.html">观察者设计模式</a></h3>
        
        <p>
            观察者设计模式


了解观察者设计模式的作用

掌握Observable类Observer接口使用


如果要是先观察者模式 必须继承接口
package KownClass;

import java.util.*;

class House extends Observable { // 表示房子可以被观察
	private float price;// 价钱

        </p>
    </li>
                                              <li>
        <h3><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/javajichujiaqiang/lijieJavaduixiangxuliehua/index.html">理解Java对象序列化</a></h3>
        
        <p>
            理解Java对象序列化


转载 http://www.blogjava.net/jiangshachina/archive/2012/02/13/369898.html
关于Java序列化的文章早已是汗牛充栋了，本文是对我个人过往学习，理解及应用Java序列化的一个总结。此文内容涉及Java序列化的基本原理，以及多种方法对序列化形式进行定制。在撰写本文时，既参考了Thinking in 
        </p>
    </li>
                                              <li>
        <h3><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/javajichujiaqiang/duoxianchengzhitongbuhesisuo/index.html">多线程之同步和死锁</a></h3>
        
        <p>
            多线程之同步和死锁


在多线程的开发中， 同步与死锁的概念非常重要


我需要知道的是 那里需要同步 
                如何实现同步 代码了解即可

以及实现同步之后 有哪些副作用
接下来以买火车票为例
package ThreadTest;
class Tong implements Runnable{
	private int ticket=5;

        </p>
    </li>
                                              <li>
        <h3><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/javajichujiaqiang/congjavawangluobianchengxueqi3/index.html">从java网络编程学起（3）</a></h3>
        
        <p>
            从java网络编程学起（3）


URLEncoder 与URLDeoder



了解编码和解码的操作




实例
package KownClass ;

import java.net.URLDecoder ;
import java.net.URLEncoder ;
public class FactoryDemo02{
	public static 
        </p>
    </li>
                                              <li>
        <h3><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/javajichujiaqiang/Javachangyongleikuzhiriqicaozuolei/index.html">Java常用类库之日期操作类</a></h3>
        
        <p>
            Java常用类库之日期操作类


Date类的使用 
Calendar类的取得一个完整的日期


Data类是一个较为常用的类 但是其操作的日期格式会有一些不符合个人要求

如果要进一步起的一些自己需要的时间 就可以使用Calendar类


（1）data类的使用
package KownClass;
import java.util.Date ;
public c
        </p>
    </li>
                                              <li>
        <h3><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/javajichujiaqiang/JavachangyongleikuzhiStringbuffer/index.html">Java常用类库之Stringbuffer</a></h3>
        
        <p>
            Java常用类库之Stringbuffer


认识StringBuffer 


StringBuffer 是使用缓冲区的，本身也是操作字符串的但是与String类不同String内容一旦声明就不能改变。，
改变的只是内存地址的指向，而Stringbuffer的内容是可以改变的

对于Stringbuffer而已，本身就是一一个具体的操作类 所以不能像String那样采用赋值的
        </p>
    </li>
                                              <li>
        <h3><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/javajichujiaqiang/javajichumianxiangduixiangleiyuduixiangdedingyi/index.html">java基础面向对象、类与对象的定义</a></h3>
        
        <p>
            java基础面向对象、类与对象的定义


面向对象的三大特征“
封装 对外部不可见
继承 扩展类的功能
多态：方法的重载 

   对象的多态性


面向对象的核心组成部分：类与对象
类是对某一类事物的描述，是抽象的 概念上的定义：
对象是实际存在的 该类事物的每个个体因而也称作实例



类与对象的关系：类是具有相同或相似结构、操作和约束规则的对象组成的集合，而
        </p>
    </li>
                                              <li>
        <h3><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/javajichujiaqiang/javajichuzhileiyuduixiangdejinyibuyanjiu/index.html">java基础之类与对象的进一步研究</a></h3>
        
        <p>
            java基础之类与对象的进一步研究


类属于引用传递类型，数组中可以知道，引用数据类型必然存在占内存堆内存实际上类与对象的使用依然存在的这样的关系


Person per=new Person（）；
声明对象：栈内存中声明的，与数组一样，数组名称就保存在
栈内存中 只开辟栈你内存是无法使用的 必须要有堆内存的引用才能使用
实例化对象：new Person（）在堆中开辟空间 所
        </p>
    </li>
                                              <li>
        <h3><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/javajichujiaqiang/javajichuzhigouzaofangfa/index.html">java基础之构造方法</a></h3>
        
        <p>
            java基础之构造方法


记住一句话：一旦有对象实例化就会调用构造方法




 构造方法的名称必须与类名称一样
 构造方法的声明不能有任何返回值类型的声明
 不能在构造方法中使用return返回一个值



每当创建一个类 默认创建一个无参的构造方法
写一个带有参数的构造方法


package KownClass;

class Person{
	p
        </p>
    </li>
                                              <li>
        <h3><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/javajichujiaqiang/javajichuzhijiekouyuchouxiang/index.html">java基础之接口与抽象</a></h3>
        
        <p>
            java基础之接口与抽象


接口是java中最重要的概念，接口可以理解为一种特殊的类，里面全部是全局常量和公共的抽象方法所组成
格式
interface A{		// 定义接口A
	public static final String AUTHOR = "李兴华" ;	// 全局常量
	public abstract void print() ;	// 抽象方法
	public 
        </p>
    </li>
                                              <li>
        <h3><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/javajichujiaqiang/javajichuzhichouxiangleiyujiekoudeyingyonger/index.html">java基础之抽象类与接口的应用（二）</a></h3>
        
        <p>
            java基础之抽象类与接口的应用（二）


（1）代理设计模式的作用






2.适配器设计模式的作用



package KownClass;

interface Window{		// 定义Window接口，表示窗口操作
	public void open() ;	// 打开
	public void close() ;	// 关闭
	public
        </p>
    </li>
                                              <li>
        <h3><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/javajichujiaqiang/javajichuzhichouxiangleiyujiekoudeyingyongyi/index.html">java基础之抽象类与接口的应用（一）</a></h3>
        
        <p>
            java基础之抽象类与接口的应用（一）


（1）掌握抽象类及接口的实例化操作


在java中可以通过对象的多态性，为抽象类和接口实例化，这样再使用抽象类和接口的时候就可以调用本之类中说覆写过的方法


之所以抽象类和接口不能直接实例化是因为内部包含各个抽象方法，抽象方法本身就是未实现的方法 所以无法 调用



1.通过对象多态性可以发现，子类发生了向上转型关系之后，
        </p>
    </li>
                                              <li>
        <h3><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/javajichujiaqiang/javajichuzhiduixiangdeduotaixing/index.html">java基础之对象的多态性</a></h3>
        
        <p>
            java基础之对象的多态性


要求 掌握对象的向上转型及向下转型的使用
掌握对象转型的限制

多态性在两种主要体现
1.方法的重载和覆写
2.对象的多态


掌握了多态性之后 可以直接应用在抽象类和接口上


说了那么多 还是放一个实体理解下
package KownClass;

class A{					// 定义类A
	public void fun1(
        </p>
    </li>
                                              <li>
        <h3><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/javajichujiaqiang/javajichuzhifanshe2classleideshiyong/index.html">java基础之反射（2class类的使用）</a></h3>
        
        <p>
            java基础之反射（2class类的使用）


本章主旨： 可以使用class类完成对象的实例化操作
可以通过construct类调用有参构造方法完成对象的实例化操作
class主要反射的源头 不光可以取得对象所在类的信息也可以通过class方法进行对象实例化操作

正常情况下使用new关键字为对象实例化，如果现在已经实例化好了Class对象则就可以通过提供的
以下代码进行演示 必
        </p>
    </li>
                                              <li>
        <h3><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/javajichujiaqiang/javajichuzhifanshe1renshiclasslei/index.html">java基础之反射（1认识class类）</a></h3>
        
        <p>
            java基础之反射（1认识class类）


（1）认识class类
正常情况下 ，必须知道一个类的完整路径之后才可以实例化对象，但是在java中也允许通过一个对象找到其所在累的信息
那么这实际上就是class类的功能


实例化 class类对象的方法有三种


第一种 通过forName（）方法
第二种 类.class 

第三种： 对象.getclass
下面用
        </p>
    </li>
                                              <li>
        <h3><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/javajichujiaqiang/javajichuzhinimingneibulei/index.html">java基础之匿名内部类</a></h3>
        
        <p>
            java基础之匿名内部类


（1）匿名内部类的作用 
只使用一次提高效率
（2）定义格式
内部类在一个类中还有一个类称内部类 那么匿名内部类 如果只使用一次就可以定义为匿名内部类
匿名内部类是在抽线及接口的基础之上发展起来的
举例
interface A{
	public void printInfo() ;	// 
}
class B implements A{	// 
        </p>
    </li>
                                              <li>
        <h3><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/javajichujiaqiang/javajichuzhibaozhuanglei/index.html">java基础之包装类</a></h3>
        
        <p>
            java基础之包装类


（1）装箱及拆箱 
将基本数据类型变为包装类称为装箱
反之就是拆箱

package KownClass;

public class test1{
	public static void main(String args[]){
		int x = 30 ;		// 基本数据类型
		Integer i = new Integer(x) ;	//
        </p>
    </li>
                                              <li>
        <h3><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/javajichujiaqiang/javajichuzhiStringlei/index.html">java基础之String类</a></h3>
        
        <p>
            java基础之String类


1.实例化对象
第一种String sb="傻逼"
第二种 String sb=new String("傻逼");
2.==和equals的区别 
==是地址值比对  equals是内容比对
3.字符串的内容一单声明就不能改变


4.String类的常用方法
（1）字符串与数组之间的转变 char c[] =str.toCharArray
        </p>
    </li>
                                              <li>
        <h3><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/javajichujiaqiang/javazhiduoxianchengrenshi/index.html">java之多线程认识</a></h3>
        
        <p>
            java之多线程认识


多线程实现有两个类：
Thread类 多线程操作类 继承Thread类 覆写run方法 


class 类名称 extend Thread{
属性
方法
public void run（）{
线程主体
}

}
测试代码
package ThreadTest;
class MyThread extends Thread{
	priva
        </p>
    </li>
                                              <li>
        <h3><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/javajichujiaqiang/javazhiduoxianchengshilishengchanzheyuxiaofeizhe/index.html">java之多线程实例生产者与消费者</a></h3>
        
        <p>
            java之多线程实例生产者与消费者


 1.加深线程同步操作的理解

 2.了解object类中对线程的支持方法






package ThreadTest;

class Info{	// 定义信息类
	private String name = "李兴华";	 // 定义name属性
	private String content = "JAVA讲师" 
        </p>
    </li>
                                              <li>
        <h3><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/javajichujiaqiang/javazhiduoxianchengshili/index.html">java之多线程实例</a></h3>
        
        <p>
            java之多线程实例



这个题目主要联系多线程的模板代码和 Thread.sleep的使用
package ThreadTest;
class Work implements Runnable{
 private String name;
 private int time;
 
	public Work(String name, int time) {
	super()
        </p>
    </li>
                                              <li>
        <h3><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/javajichujiaqiang/javazhiIoFilelei/index.html">java之IoFile类</a></h3>
        
        <p>
            java之IoFile类


（1） 用File类创建一个文件  
考虑到可移植性 加入 File.separator
package IoDemo;

import java.io.File;
import java.io.IOException;

public class FileDemo {
public static void main(String[] args)
        </p>
    </li>
                                              <li>
        <h3><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/javajichujiaqiang/JavazhongArrayListheLinkedListqubie/index.html">Java中ArrayList和LinkedList区别</a></h3>
        
        <p>
            Java中ArrayList和LinkedList区别


转载于 http://pengcqu.iteye.com/blog/502676
一般大家都知道ArrayList和LinkedList的大致区别： 
1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 
2.对于随机访问get和set，ArrayList觉得优于LinkedList
        </p>
    </li>
                                              <li>
        <h3><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/javajichujiaqiang/javasandatexingzhifengzhuang/index.html">java三大特性之封装</a></h3>
        
        <p>
            java三大特性之封装


1.封装的产生目的 
2.掌握封装的实现
3.掌握setter和getter 的定义


为什么要封装？
封装就是保护内容

保证某些属性或方法可以不被外面看见


看看下面的代码存在的问题：


class Person{
	String name ;			// 声明姓名属性
	int age ;				// 声明年龄属性
	p
        </p>
    </li>
                                              <li>
        <h3><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/javajichujiaqiang/java15gaoxinzhishizhifanxing3/index.html">java15高新知识之泛型（3）</a></h3>
        
        <p>
            java15高新知识之泛型（3）


（1）泛型接口的使用


之前的所有操作都是在类中直接使用泛型操作的 那么java来说也可以直接在接口中定义及使用泛型


泛型在接口中实现的两种形式
定义子类：在子类的定义上声明泛型类型
package KownClass;
interface Info{		// 在接口上定义泛型
	public T getVar() ;	// 定
        </p>
    </li>
                                              <li>
        <h3><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/javajichujiaqiang/java15gaoxinzhishizhifanxing2/index.html">java15高新知识之泛型（2）</a></h3>
        
        <p>
            java15高新知识之泛型（2）


掌握通配符?的使用
（1）匹配任意类型的通配符
在开发中对象的引用传递时最常见的 但是如果在泛型类中操作中

在进行应用传递的时候泛型类型必须匹配才可以传递，否则是无法传递的


如果将fun改成 Info 就可以使用泛型了
	public static void fun(Info i){		// 接收Object泛型类型的Info对象
        </p>
    </li>
                                              <li>
        <h3><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/javajichujiaqiang/java15gaoxinzhishizhifanxing1/index.html">java15高新知识之泛型（1）</a></h3>
        
        <p>
            java15高新知识之泛型（1）


（1）泛型产生的意义

泛型可以解决数据类型的安全性问题，它主要的原理是类声明的时候通过一个标示表示类中某个属性的类型或者是某个方法的返回值的参数类型，这样在类声明或实例化的时候只要指定好的类型即可


按照此格式写一个类
package KownClass;

class Point{		// 此处可以随便写标识符号，T是type的简称
        </p>
    </li>
                                              <li>
        <h3><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/javajichujiaqiang/java15gaoxintexingzhimeiju1/index.html">java15高新特性之枚举（1）</a></h3>
        
        <p>
            java15高新特性之枚举（1）


1.掌握枚举的作用
在jdk1.5之前 java可以有2钟方式定义新类型：类和接口对于大部分面向对象编程来说，这两种方法看起来似乎足够了
但是一些特殊的情况下 这些方法就不适合 ，其他任何值都是非法的如果有枚举就能很简单的实现了



所谓的枚举就是规定好指定的取值范围 所有内容只能从指定的范围中取得使用简单类完成颜色的固定取值问题
也就是
        </p>
    </li>
                      			
    </ul>
                </div>

                <div class='span3 sidebar'>
                    <h2>导航栏</h2>
                    <ul class="nav nav-tabs nav-stacked">
                             				<li><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/gaofangzhuomingAPPkaifalei/index.html">高仿著名APP开发类[7]</a></li>
    				          				<li><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/weifenlei/index.html">未分类[1]</a></li>
    				          				<li><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/kuaisukaifa/index.html">快速开发[17]</a></li>
    				          				<li><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/anzhuowangluobiancheng/index.html">安卓网络编程[12]</a></li>
    				          				<li><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/anzhuokuaisurumenlianshouxiaoxiangmuxilie/index.html">安卓快速入门——练手小项目系列[6]</a></li>
    				          				<li><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/anzhuojichudehuigu/index.html">安卓基础的回顾[35]</a></li>
    				          				<li><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/anzhuozhijishuguilei/index.html">安卓之技术归类[4]</a></li>
    				          				<li><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/yipianwenzhangjiunengzaijianlishangjiayitiaojishudian/index.html">一片文章就能在简历上加一条技术点[1]</a></li>
    				          				<li><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/javajichujiaqiang/index.html">java基础加强[28]</a></li>
    				          				<li><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/appkaifazhiwogeinisilu/index.html">app开发之我给你思路[3]</a></li>
    				          				<li><a href="http://songboriceboy.github.io/gitDemo/html/Jack_King007dezhuanlan_CSDN/androiddaimayouhua/index.html">android代码优化[2]</a></li>
    				                                         
                    </ul>
                </div>
            </div>

        </div>
    </body>
</html>